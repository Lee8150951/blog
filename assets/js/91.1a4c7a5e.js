(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{592:function(e,_,t){"use strict";t.r(_);var v=t(7),n=Object(v.a)({},(function(){var e=this,_=e.$createElement,t=e._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"_1、算法策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、算法策略"}},[e._v("#")]),e._v(" 1、算法策略")]),e._v(" "),t("p",[e._v("React的调和算法，主要发生在render阶段，调和算法并不是一个特定的算法函数，而是指在调和过程中，为提高构建workInProcess树的性能，以及Dom树更新的性能，而采用的一种策略，又称diffing算法。 在React 的官网上描述“Diffing” 算法时，提到了“diffing two trees”，但是在源码实现时，并不是创建好两棵树后，再从上往下的diffing这两棵树。这个diffing发生在搭建子节点时, 实际是新生成的ReactElement 与 current树上fibe节点的diffing。 为了将diffing算法的时间复杂度控制在O(n)（树diff的时间复杂度涉及到树的编辑距离，可以看这里）, 采用了如下策略：")]),e._v(" "),t("p",[e._v("1）只比较同层级的节点")]),e._v(" "),t("p",[e._v("2）对于单节点比较，如果当前节点type 和 key 不相同，不再比较其下子节点，直接删掉该节点及其下整棵子树，根据ReactElement重新生成节点树。因为React认为不同类型的组件生成的树形结构不一样，不必复用。")]),e._v(" "),t("p",[e._v("3）如果子节点是数组，可根据唯一的key值定位节点进行比较，这样即使子节点顺序发生变化，也可以根据key值进行复用。")]),e._v(" "),t("p",[e._v("值得注意的是，"),t("strong",[e._v("所有节点的diffing都会比较key，key 默认值为null。若是没有设置，则null是恒等于null的，认为key是相同的")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"_2、key的相关问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、key的相关问题"}},[e._v("#")]),e._v(" 2、Key的相关问题")]),e._v(" "),t("p",[t("strong",[e._v("虚拟DOM中key的作用")])]),e._v(" "),t("p",[e._v("1）简单的说：key是虚拟DoM对象的标识，在更新显示时key起着极其重要的作用")]),e._v(" "),t("p",[e._v("2）详细的说：当状态中的数据发生变化时， react会根据【新数据】生成【新的虚拟DOM】，随后 React进行【新虚拟DOM】与【旧虚拟DOM】的diffing比较，比较规则如下：")]),e._v(" "),t("p",[e._v("a、旧虚拟DOM中找到了与新虚拟DOM相同的key：")]),e._v(" "),t("p",[e._v("（1）若虚拟DOM中内容没变，直接使用之前的真实DON")]),e._v(" "),t("p",[e._v("（2）若虚拟DOM内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM")]),e._v(" "),t("p",[e._v("b、旧虚拟DOM中未找到与新虚拟DOM相同的key根据数据创建新的真实DOM，随后渲染到到页面")]),e._v(" "),t("p",[t("strong",[e._v("用index作为key可能会引发的问题")])]),e._v(" "),t("p",[e._v("1、若对数据进行：逆序添加、逆序删除等破坏顺序操作：")]),e._v(" "),t("p",[e._v("​\t\t会产生没有必要的真实DOM更新 ==> 界面效果没问题，但效率低")]),e._v(" "),t("p",[e._v("2、如果结构中还包含输入类的DOM：")]),e._v(" "),t("p",[e._v("​\t\t会产生错误DOM更新 ==> 界面有问题")]),e._v(" "),t("p",[e._v("3、如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用 index作为key是没有问题的")]),e._v(" "),t("p",[t("strong",[e._v("开发中如何选择key")])]),e._v(" "),t("p",[e._v("1、最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值")]),e._v(" "),t("p",[e._v("2、如果确定只是简单的展示数据，用 index也是可以的")])])}),[],!1,null,null,null);_.default=n.exports}}]);